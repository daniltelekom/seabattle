<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>SeaStrike ‚Äî Placement fixed (touch)</title>
  <script src="https://telegram.org/js/telegram-web-app.js"></script>
  <style>
    *{box-sizing:border-box;margin:0;padding:0}
    body{font-family:sans-serif;padding:14px;background:#e3f2fd;color:#072146}
    h2{margin-bottom:8px}
    .row{display:flex;gap:8px;align-items:center;margin:8px 0}
    .btn{padding:10px 12px;border-radius:10px;border:0;background:#1976d2;color:#fff;font-weight:700;cursor:pointer}
    .btn.secondary{background:#90a4ae}
    .panel{background:#fff;padding:10px;border-radius:10px;box-shadow:0 4px 10px rgba(3,27,66,0.06)}
    .grid{display:grid;grid-template-columns:repeat(10,1fr);gap:4px;margin-top:12px}
    .cell{aspect-ratio:1;background:#e8f3ff;border-radius:6px;display:flex;align-items:center;justify-content:center;font-size:12px;color:#0b3d91;user-select:none;touch-action:manipulation}
    .cell.occupied{background:#90caf9}
    .cell.bad{background:#ffcdd2}
    .ships-panel{display:flex;flex-wrap:wrap;gap:8px}
    /* –°–¥–µ–ª–∞–µ–º —Ä–µ–∞–ª—å–Ω—ã–µ –∫–Ω–æ–ø–∫–∏ ‚Äî –æ–Ω–∏ –Ω–∞–¥—ë–∂–Ω–µ–π —Ä–∞–±–æ—Ç–∞—é—Ç –Ω–∞ –º–æ–±–∏–ª—å–Ω—ã—Ö */
    .ship-btn{padding:8px 10px;border-radius:8px;background:#2196f3;color:#fff;font-weight:700;cursor:pointer;min-width:44px;text-align:center;border:none}
    .ship-btn.selected{outline:3px solid #ffca28}
    .controls{display:flex;gap:8px;flex-wrap:wrap;margin-top:8px}
    .rules{font-size:13px;color:#263238;margin-top:8px}
    #status{margin-top:8px;font-weight:700}
    @media (max-width:520px){
      body{padding:10px}
      .cell{font-size:11px}
      .ship-btn{min-width:34px;padding:6px}
    }
    /* –Ω–µ–±–æ–ª—å—à–æ–π –æ—Ç–ª–∞–¥–æ—á–Ω—ã–π –±–ª–æ–∫ (—Å–∫—Ä—ã–≤–∞–µ–º, –µ—Å–ª–∏ –Ω–µ –Ω—É–∂–Ω–æ) */
    #dbg { position:fixed; right:8px; bottom:8px; background:rgba(0,0,0,0.6); color:#fff; padding:6px 8px; border-radius:6px; font-size:12px; z-index:9999 }
  </style>
</head>
<body>
  <h2>SeaStrike ‚Äî —Ä–∞—Å—Å—Ç–∞–Ω–æ–≤–∫–∞ (—Ñ–∏–∫—Å –¥–ª—è touch)</h2>

  <div class="panel">
    <div class="row">
      <div style="flex:1">
        <div class="ships-panel" id="shipsPanel" aria-label="–ü–∞–Ω–µ–ª—å –∫–æ—Ä–∞–±–ª–µ–π"></div>
        <div class="controls">
          <button class="btn secondary" id="rotateBtn">–ü–æ–≤–µ—Ä–Ω—É—Ç—å (H)</button>
          <button class="btn secondary" id="autoBtn">üîÄ –ê–≤—Ç–æ</button>
          <button class="btn secondary" id="undoBtn">‚Ü∂ –û—Ç–º–µ–Ω–∏—Ç—å –ø–æ—Å–ª–µ–¥–Ω–∏–π</button>
          <button class="btn secondary" id="eraseModeBtn">üßΩ –†–µ–∂–∏–º —É–¥–∞–ª–µ–Ω–∏—è: –≤—ã–∫–ª</button>
        </div>
        <div class="rules" id="rules">
          <b>–ü—Ä–∞–≤–∏–ª–∞:</b> –ù–∞–±–æ—Ä: 1√ó4, 2√ó3, 3√ó2, 4√ó1. –¢–∞–ø–Ω–∏ –ø–æ –∫–æ—Ä–∞–±–ª—é –≤ –ø–∞–Ω–µ–ª–∏ ‚Üí —Ç–∞–ø–Ω–∏ –ø–æ –∫–ª–µ—Ç–∫–µ –ø–æ–ª—è. –ü–æ–≤–µ—Ä–Ω—É—Ç—å ‚Äî –∫–Ω–æ–ø–∫–∞. –£–¥–∞–ª–µ–Ω–∏–µ —á–µ—Ä–µ–∑ —Ä–µ–∂–∏–º —É–¥–∞–ª–µ–Ω–∏—è.
        </div>
      </div>
      <div style="width:220px;margin-left:12px">
        <div style="font-size:13px">–°—Ç–∞—Ç—É—Å</div>
        <div id="status" class="panel">–ì–æ—Ç–æ–≤—å —Ä–∞—Å—Å—Ç–∞–Ω–æ–≤–∫—É</div>
      </div>
    </div>

    <div style="margin-top:12px" id="myFieldContainer">
      <div class="grid" id="myField" aria-label="–ò–≥—Ä–æ–≤–æ–µ –ø–æ–ª–µ"></div>
    </div>

    <div style="display:flex;gap:8px;margin-top:12px">
      <button class="btn" id="readyBtn" disabled>‚úÖ –ì–æ—Ç–æ–≤–æ</button>
      <button class="btn secondary" id="backBtn">‚¨Ö –ù–∞–∑–∞–¥</button>
    </div>
  </div>

  <div id="dbg" style="display:none">DBG</div>

  <script>
    // --- init Telegram fallback ---
    const WebApp = window.Telegram?.WebApp || null;
    const initUser = WebApp?.initDataUnsafe?.user || { id: 12345, username: 'local_test' };
    const userId = initUser.id;
    try { if (WebApp) WebApp.expand?.(); } catch(e){ console.warn(e); }

    // --- safety: show runtime errors in status for mobile debugging ---
    const statusEl = document.getElementById('status');
    window.addEventListener('error', e => {
      console.error('JS error', e.error || e.message);
      statusEl.textContent = 'Error: ' + (e.error?.message || e.message || 'unknown');
      const dbg = document.getElementById('dbg');
      dbg.style.display = 'block';
      dbg.textContent = (e.error?.message || e.message || 'err').slice(0,120);
    });
    window.addEventListener('unhandledrejection', ev => {
      console.error('Promise rejection', ev.reason);
      statusEl.textContent = 'Promise rejection: ' + (ev.reason?.message || String(ev.reason)).slice(0,80);
    });

    // ---- ship set ----
    const SHIP_SIZES = [4,3,3,2,2,2,1,1,1,1];
    function groupSizes(arr){ const out = {}; arr.forEach(s => out[s] = (out[s] || 0) + 1); return out; }
    let shipsPool = groupSizes(SHIP_SIZES);
    let placed = []; // placed ships
    let nextShipId = 1;
    let selectedSize = null;
    let orientation = 'H';
    let eraseMode = false;

    // worker fallback (same as —Ä–∞–Ω—å—à–µ)
    let worker = null;
    try { worker = new Worker('mock-worker.js'); } catch(e){ worker = null; }
    function mockFetch(path, data = {}) {
      if (worker) {
        return new Promise(resolve=>{
          const url = 'http://mock' + path;
          const onMsg = e => {
            if (e.data && e.data.url === url){ resolve(e.data.result); worker.removeEventListener('message', onMsg); }
            else if (e.data && e.data.error){ resolve(e.data); worker.removeEventListener('message', onMsg); }
          };
          worker.addEventListener('message', onMsg);
          worker.postMessage({ url, method:'POST', body: data });
        });
      } else {
        // minimal endpoints for placement flow
        const endpoints = {
          '/match/random/join': ()=>({ status:'matched', match_id:'demo-123', opponent_id:999999, is_your_turn:true }),
          '/match/demo-123/place-ships': ()=>({ status:'ok' }),
          '/match/demo-123/wait-ready': ()=>({ status:'ready' })
        };
        return new Promise(resolve => setTimeout(()=> resolve(endpoints[path] ? endpoints[path](data) : { error:'not found' }), 80));
      }
    }

    // --- UI build ---
    const myField = document.getElementById('myField');
    const shipsPanel = document.getElementById('shipsPanel');
    const rotateBtn = document.getElementById('rotateBtn');
    const autoBtn = document.getElementById('autoBtn');
    const undoBtn = document.getElementById('undoBtn');
    const eraseModeBtn = document.getElementById('eraseModeBtn');
    const readyBtn = document.getElementById('readyBtn');
    const backBtn = document.getElementById('backBtn');
    const dbg = document.getElementById('dbg');

    function buildField(){
      myField.innerHTML = '';
      for (let i=0;i<100;i++){
        const c = document.createElement('div');
        c.className = 'cell';
        c.dataset.idx = i;
        // support both click and touchend reliably
        c.addEventListener('click', onCellClick);
        c.addEventListener('touchend', function(e){ e.preventDefault(); onCellClick.call(this, e); });
        myField.appendChild(c);
      }
    }

    function renderShipsPanel(){
      shipsPanel.innerHTML = '';
      const unique = Array.from(new Set(SHIP_SIZES)).sort((a,b)=>b-a);
      unique.forEach(size => {
        const countLeft = shipsPool[size] || 0;
        const btn = document.createElement('button');
        btn.className = 'ship-btn' + (selectedSize===size ? ' selected' : '');
        btn.type = 'button';
        btn.innerText = `${size} √ó ${countLeft}`;
        btn.dataset.size = size;
        // click & touch support
        const handler = (ev) => {
          ev.preventDefault();
          if (countLeft <= 0) { statusEl.textContent = '–ù–µ—Ç —Ç–∞–∫–∏—Ö –∫–æ—Ä–∞–±–ª–µ–π'; return; }
          selectedSize = (selectedSize === size) ? null : size;
          renderShipsPanel();
          updateStatus();
        };
        btn.addEventListener('click', handler);
        btn.addEventListener('touchend', function(e){ e.preventDefault(); handler(e); });
        shipsPanel.appendChild(btn);
      });
    }

    function cellCoords(idx){ return { x: idx % 10, y: Math.floor(idx/10) }; }
    function cellsForPlacement(startIdx, size, orient){
      const {x,y} = cellCoords(startIdx);
      const cells = [];
      if (orient === 'H'){
        for (let k=0;k<size;k++){
          const nx = x + k;
          if (nx > 9) return null;
          cells.push(y*10 + nx);
        }
      } else {
        for (let k=0;k<size;k++){
          const ny = y + k;
          if (ny > 9) return null;
          cells.push(ny*10 + x);
        }
      }
      return cells;
    }
    function overlaps(cells){ const occupied = new Set(placed.flatMap(s => s.cells)); return cells.some(c => occupied.has(c)); }

    function placeShipAt(startIdx, size, orient){
      const cells = cellsForPlacement(startIdx, size, orient);
      if (!cells) return { ok:false, reason:'out' };
      if (overlaps(cells)) return { ok:false, reason:'overlap' };
      const ship = { id: nextShipId++, size, startIdx, orientation: orient, cells };
      placed.push(ship);
      shipsPool[size] = (shipsPool[size] || 0) - 1;
      renderAll();
      return { ok:true, ship };
    }

    function findShipByCell(idx){ return placed.find(s => s.cells.includes(idx)); }
    function removeShipById(id){ const idx = placed.findIndex(s => s.id === id); if (idx === -1) return false; const s = placed[idx]; shipsPool[s.size] = (shipsPool[s.size] || 0) + 1; placed.splice(idx,1); renderAll(); return true; }

    function renderAll(){
      document.querySelectorAll('#myField .cell').forEach(c => { c.classList.remove('occupied','bad'); c.textContent = ''; });
      placed.forEach(s => {
        s.cells.forEach((ci,i) => {
          const el = myField.children[ci];
          if (!el) return;
          el.classList.add('occupied');
          if (i===0) el.textContent = s.size;
        });
      });
      renderShipsPanel();
      readyBtn.disabled = !allPlaced();
      updateStatus();
    }

    function allPlaced(){ return Object.values(shipsPool).every(v => v === 0); }

    function updateStatus(msg){
      if (msg) { statusEl.textContent = msg; return; }
      if (allPlaced()) statusEl.textContent = '–í—Å–µ –∫–æ—Ä–∞–±–ª–∏ —Ä–∞—Å—Å—Ç–∞–≤–ª–µ–Ω—ã ‚Äî –Ω–∞–∂–º–∏ –ì–æ—Ç–æ–≤–æ';
      else if (selectedSize) statusEl.textContent = `–í—ã–±—Ä–∞–Ω–æ: ${selectedSize} (–æ—Ä–∏–µ–Ω—Ç–∞—Ü–∏—è ${orientation})`;
      else statusEl.textContent = '–í—ã–±–µ—Ä–∏ –∫–æ—Ä–∞–±–ª—å –≤ –ø–∞–Ω–µ–ª–∏ –∏ —Ç–∞–ø–Ω–∏ –ø–æ –ø–æ–ª—é';
    }

    // handlers
    function onCellClick(ev){
      // ev.currentTarget or this
      const el = ev.currentTarget || this;
      const idx = parseInt(el.dataset.idx);
      if (eraseMode){
        const ship = findShipByCell(idx);
        if (ship){ removeShipById(ship.id); updateStatus('–ö–æ—Ä–∞–±–ª—å —É–¥–∞–ª—ë–Ω'); }
        else updateStatus('–ü–æ —ç—Ç–æ–π –∫–ª–µ—Ç–∫–µ –Ω–µ—Ç –∫–æ—Ä–∞–±–ª—è');
        return;
      }
      if (!selectedSize){ updateStatus('–°–Ω–∞—á–∞–ª–∞ –≤—ã–±–µ—Ä–∏ –∫–æ—Ä–∞–±–ª—å'); return; }
      const res = placeShipAt(idx, selectedSize, orientation);
      if (!res.ok){
        if (res.reason === 'out') updateStatus('–ù–µ –≤–ª–µ–∑–∞–µ—Ç –≤ –≤—ã–±—Ä–∞–Ω–Ω—É—é –æ—Ä–∏–µ–Ω—Ç–∞—Ü–∏—é');
        else if (res.reason === 'overlap') updateStatus('–ù–∞–ª–æ–∂–µ–Ω–∏–µ ‚Äî –≤—ã–±–µ—Ä–∏ –¥—Ä—É–≥–æ–µ –º–µ—Å—Ç–æ');
        else updateStatus('–ù–µ–≤–æ–∑–º–æ–∂–Ω–æ –ø–æ—Å—Ç–∞–≤–∏—Ç—å');
      } else {
        updateStatus('–ö–æ—Ä–∞–±–ª—å –ø–æ—Å—Ç–∞–≤–ª–µ–Ω');
        if ((shipsPool[selectedSize] || 0) <= 0) selectedSize = null;
      }
    }

    rotateBtn.addEventListener('click', ()=>{
      orientation = (orientation==='H') ? 'V' : 'H';
      rotateBtn.innerText = `–ü–æ–≤–µ—Ä–Ω—É—Ç—å (${orientation})`;
      updateStatus();
    });
    rotateBtn.addEventListener('touchend', e => { e.preventDefault(); rotateBtn.click(); });

    autoBtn.addEventListener('click', ()=>{ randomPlaceAll(); updateStatus('–ê–≤—Ç–æ-—Ä–∞—Å—Å—Ç–∞–Ω–æ–≤–∫–∞'); });
    autoBtn.addEventListener('touchend', e=>{ e.preventDefault(); autoBtn.click(); });

    undoBtn.addEventListener('click', ()=>{
      if (placed.length===0){ updateStatus('–ù–µ—á–µ–≥–æ –æ—Ç–º–µ–Ω—è—Ç—å'); return; }
      const last = placed.pop();
      shipsPool[last.size] = (shipsPool[last.size] || 0) + 1;
      renderAll();
      updateStatus('–û—Ç–º–µ–Ω—ë–Ω –ø–æ—Å–ª–µ–¥–Ω–∏–π');
    });
    undoBtn.addEventListener('touchend', e=>{ e.preventDefault(); undoBtn.click(); });

    eraseModeBtn.addEventListener('click', ()=>{
      eraseMode = !eraseMode;
      eraseModeBtn.innerText = `üßΩ –†–µ–∂–∏–º —É–¥–∞–ª–µ–Ω–∏—è: ${eraseMode ? '–≤–∫–ª' : '–≤—ã–∫–ª'}`;
    });
    eraseModeBtn.addEventListener('touchend', e=>{ e.preventDefault(); eraseModeBtn.click(); });

    readyBtn.addEventListener('click', async ()=>{
      if (!allPlaced()){ updateStatus('–°–Ω–∞—á–∞–ª–∞ —Ä–∞–∑–º–µ—Å—Ç–∏ –≤—Å–µ –∫–æ—Ä–∞–±–ª–∏'); return; }
      readyBtn.disabled = true;
      updateStatus('–û—Ç–ø—Ä–∞–≤–∫–∞...');
      try {
        await mockFetch('/match/random/join', { telegram_id: userId });
        await mockFetch('/match/demo-123/place-ships', { telegram_id: userId, ships: placed });
        updateStatus('–û—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ ‚Äî –∂–¥—ë–º —Å—Ç–∞—Ä—Ç–∞...');
        setTimeout(async ()=>{ await mockFetch('/match/demo-123/wait-ready', { telegram_id: userId }); updateStatus('–ú–∞—Ç—á –Ω–∞—á–∞–ª—Å—è (–¥–µ–º–æ)'); }, 600);
      } catch(err){
        console.error(err);
        updateStatus('–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏');
      } finally { readyBtn.disabled = !allPlaced(); }
    });
    readyBtn.addEventListener('touchend', e=>{ e.preventDefault(); readyBtn.click(); });

    backBtn.addEventListener('click', ()=>{ updateStatus('–ù–∞–∑–∞–¥'); });
    backBtn.addEventListener('touchend', e=>{ e.preventDefault(); backBtn.click(); });

    // random placement
    function clearAll(){
      placed = [];
      shipsPool = groupSizes(SHIP_SIZES);
      nextShipId = 1;
      selectedSize = null;
      orientation = 'H';
      eraseMode = false;
      eraseModeBtn.innerText = 'üßΩ –†–µ–∂–∏–º —É–¥–∞–ª–µ–Ω–∏—è: –≤—ã–∫–ª';
      renderAll();
    }
    function randomPlaceAll(){
      clearAll();
      const sizes = [...SHIP_SIZES].sort(()=>Math.random()-0.5);
      for (const s of sizes){
        let tries = 0, ok=false;
        while(tries < 400 && !ok){
          const start = Math.floor(Math.random()*100);
          const orient = (Math.random()<0.5) ? 'H' : 'V';
          const cells = cellsForPlacement(start, s, orient);
          if (cells && !overlaps(cells)){ placed.push({ id: nextShipId++, size: s, startIdx: start, orientation: orient, cells }); shipsPool[s] = (shipsPool[s]||0)-1; ok=true; }
          tries++;
        }
        if (!ok) return randomPlaceAll(); // try whole shuffle again
      }
      renderAll();
    }

    // init
    function init(){
      buildField();
      renderShipsPanel();
      renderAll();
      updateStatus('–í—ã–±–µ—Ä–∏—Ç–µ –∫–æ—Ä–∞–±–ª—å –≤ –ø–∞–Ω–µ–ª–∏ –∏ —Ç–∞–ø–Ω–∏—Ç–µ –ø–æ –ø–æ–ª—é. –ï—Å–ª–∏ –Ω–µ —Ä–∞–±–æ—Ç–∞–µ—Ç ‚Äî –æ—Ç–∫—Ä–æ–π –≤ Telegram –µ—â—ë —Ä–∞–∑.');
      dbg.style.display = 'none';
    }
    init();
  </script>
</body>
</html>
