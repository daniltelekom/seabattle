<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
<title>SeaStrike MiniApp — Telegram</title>
<script src="https://telegram.org/js/telegram-web-app.js"></script>

<style>
:root{--accent:#1976d2;--bg:#e9f4ff;--card:#fff;--cell:#e8f3ff;--hit:#f44336;--occupied:#2b9cff}
*{box-sizing:border-box;margin:0;padding:0}
body{font-family:system-ui,Roboto,Arial;margin:10px;background:var(--bg);color:#072146;display:flex;flex-direction:column;gap:8px}
.header{display:flex;justify-content:space-between;align-items:center}
.panel{background:var(--card);padding:10px;border-radius:12px;box-shadow:0 6px 18px rgba(2,20,60,0.06)}
.layout{display:grid;grid-template-columns:1fr 360px;gap:12px}
@media (max-width:920px){ .layout{grid-template-columns:1fr} }
.field-wrap{display:flex;justify-content:center;align-items:center}
.grid{display:grid;grid-template-columns:repeat(10,1fr);gap:4px;touch-action:manipulation;width:100%}
.cell{aspect-ratio:1;background:var(--cell);border-radius:8px;display:flex;align-items:center;justify-content:center;font-size:12px;user-select:none}
.cell.occupied{background:var(--occupied);color:white}
.cell.hit{background:var(--hit);color:white}
.ships-panel{display:flex;flex-wrap:wrap;gap:8px}
.ship-btn{padding:8px 10px;border-radius:8px;background:#2196f3;color:#fff;border:none;min-width:42px}
.ship-btn.selected{outline:3px solid #ffca28}
.footer{position:fixed;left:10px;right:10px;bottom:10px;display:flex;gap:8px;z-index:20}
.footer .panel{flex:1;display:flex;justify-content:space-between;align-items:center;padding:10px}
.info{font-size:13px;color:#263238}
.small{font-size:12px;color:#3b4752}
#dbg{position:fixed;right:8px;top:8px;background:rgba(0,0,0,0.6);color:#fff;padding:6px 8px;border-radius:6px;display:none}
</style>
</head>
<body>
<div class="header">
  <div><h2>SeaStrike — MiniApp</h2><div class="small">Классический морской бой. Играй с другом или в поиск.</div></div>
  <div class="small">PlayerID: <span id="playerIdLabel">—</span></div>
</div>

<div class="layout">
  <div class="panel">
    <div style="display:flex;justify-content:space-between;align-items:center">
      <div class="ships-panel" id="shipsPanel"></div>
      <div style="display:flex;gap:8px">
        <button id="rotateBtn" class="ship-btn">Повернуть (H)</button>
        <button id="autoBtn" class="ship-btn">Авто</button>
      </div>
    </div>

    <div id="fieldWrap" class="field-wrap" style="margin-top:12px">
      <div id="boardContainer" style="width:100%;max-width:560px">
        <div id="myField" class="grid"></div>
      </div>
    </div>

    <div style="display:flex;justify-content:space-between;align-items:center;margin-top:10px">
      <div id="status" class="small">Выберите корабль и тапните по полю</div>
      <div style="display:flex;gap:8px">
        <button id="undoBtn" class="ship-btn">↶ Отменить</button>
        <button id="eraseModeBtn" class="ship-btn">Удаление: выкл</button>
      </div>
    </div>

  </div>

  <div>
    <div class="panel" style="display:flex;flex-direction:column;gap:8px">
      <div style="display:flex;gap:8px">
        <select id="modeSelect"><option value="mock">Mode: mock</option><option value="railway">Mode: railway</option></select>
        <button id="createMatchBtn" class="ship-btn">Создать матч</button>
        <input id="matchIdInput" placeholder="match id для join" style="flex:1;padding:8px;border-radius:8px;border:1px solid #ddd"/>
      </div>

      <div style="display:flex;gap:8px">
        <button id="joinMatchBtn" class="ship-btn">Присоединиться</button>
        <button id="findBtn" class="ship-btn">Найти игру</button>
        <button id="leaveBtn" class="ship-btn">Выйти</button>
      </div>
      <div style="display:flex;flex-direction:column;gap:6px">
        <div class="info">Mode: <span id="modeLabel">mock</span></div>
        <div class="info">Match: <span id="matchLabel">—</span></div>
        <div class="info">Turn: <span id="turnLabel">—</span></div>
        <div class="info">Rating: <span id="ratingLabel">1000</span> • Stars: <span id="starsLabel">0</span></div>
      </div>

      <hr/>
      <div class="info"><b>Магазин</b></div>
      <div style="display:flex;flex-direction:column;gap:6px">
        <div style="display:flex;gap:8px;align-items:center">
          <img src="" alt="" style="width:48px;height:32px;background:#ddd;border-radius:6px"/>
          <div style="flex:1">
            <div class="small">Skin: Blue Ship — Цена: 50 stars</div>
            <div style="display:flex;gap:8px;margin-top:6px">
              <button id="buySkinBtn" class="ship-btn">Купить за stars</button>
              <button id="buyStarsBtn" class="ship-btn">Купить stars (через бота)</button>
            </div>
          </div>
        </div>
      </div>

    </div>
  </div>
</div>

<div id="dbg">DBG</div>

<div class="footer">
  <div class="panel">
    <div class="info">Поддержка: Railway (онлайн) / Mock (локал)</div>
    <div style="display:flex;gap:8px">
      <button id="readyBtn" class="ship-btn">✅ Готов</button>
      <button id="attackBtn" class="ship-btn" disabled>Атаковать (demo)</button>
    </div>
  </div>
</div>

  <script>
/* ====== Polling helpers (для railway REST) ====== */
let pollInterval = null;
async function pollMatchStatus() {
  if (!currentMatchId) return;
  try {
    const url = API_URL + '/match-status?matchId=' + encodeURIComponent(currentMatchId);
    const resp = await fetch(url, { method: 'GET' });
    if (!resp.ok) {
      console.warn('match-status http error', resp.status);
      return;
    }
    const data = await resp.json();
    if (!data) return;

    // Обновляем UI
    matchLabel.innerText = data.id || currentMatchId;
    modeLabel.innerText = 'railway';
    currentTurn = data.turn || null;
    turnLabel.innerText = currentTurn ? String(currentTurn) : '—';

    if (data.state === 'started' && String(currentTurn) === String(PLAYER_ID)) {
      attackBtn.disabled = false;
      updateStatus('Ваш ход');
    } else if (data.state === 'started') {
      attackBtn.disabled = true;
      updateStatus('Ход соперника');
    } else if (data.state === 'waiting') {
      attackBtn.disabled = true;
      updateStatus('Ожидание соперника/готовности');
    } else if (data.state === 'finished') {
      attackBtn.disabled = true;
      updateStatus('Матч завершён');
      stopPollingMatch();
    }
  } catch (e) {
    console.warn('poll error', e);
  }
}
function startPollingMatch() {
  stopPollingMatch();
  pollMatchStatus(); // вызвать сразу
  pollInterval = setInterval(pollMatchStatus, 2000);
}
function stopPollingMatch() {
  if (pollInterval) {
    clearInterval(pollInterval);
    pollInterval = null;
  }
}

/* ====== Matchmaking / Buttons (REST & mock) ====== */

// CREATE MATCH
createMatchBtn.addEventListener('click', async () => {
  if (modeSelect.value !== 'railway') {
    // mock flow
    currentMatchId = 'demo-' + Math.floor(Math.random() * 10000);
    matchLabel.innerText = currentMatchId;
    modeLabel.innerText = 'mock';
    updateStatus('Mock match ready: ' + currentMatchId);
    // в mock даём ход создателю
    currentTurn = PLAYER_ID;
    turnLabel.innerText = String(currentTurn);
    attackBtn.disabled = false;
    return;
  }

  // railway flow
  if (!API_URL || !API_URL.startsWith('http')) {
    updateStatus('Неверный API_URL — проверь строку с https://');
    return;
  }
  updateStatus('Создаём матч...');
  const res = await apiFetch('/create-match', { playerId: String(PLAYER_ID) });
  if (res && res.matchId) {
    currentMatchId = res.matchId;
    matchLabel.innerText = currentMatchId;
    modeLabel.innerText = 'railway';
    updateStatus('Матч создан: ' + currentMatchId);
    startPollingMatch();
  } else {
    console.error('create-match failed', res);
    updateStatus('Ошибка создания матча: ' + (res && res.error ? res.error : 'no response'));
  }
});

// JOIN MATCH
joinMatchBtn.addEventListener('click', async () => {
  const id = matchIdInput.value.trim();
  if (!id) { updateStatus('Введите match id'); return; }

  if (modeSelect.value !== 'railway') {
    currentMatchId = id;
    matchLabel.innerText = id;
    modeLabel.innerText = 'mock';
    updateStatus('Joined mock');
    currentTurn = PLAYER_ID;
    turnLabel.innerText = String(currentTurn);
    attackBtn.disabled = false;
    return;
  }

  updateStatus('Присоединяемся к ' + id + '...');
  const res = await apiFetch('/join-match', { matchId: id, playerId: String(PLAYER_ID) });
  if (res && res.ok) {
    currentMatchId = id;
    matchLabel.innerText = currentMatchId;
    modeLabel.innerText = 'railway';
    updateStatus('Успешно присоединился: ' + id);
    startPollingMatch();
  } else {
    console.error('join-match failed', res);
    updateStatus('Ошибка join: ' + (res && res.error ? res.error : 'no response'));
  }
});

// FIND (queue)
findBtn.addEventListener('click', async () => {
  if (modeSelect.value !== 'railway') { updateStatus('Mock: нет поиска'); return; }
  updateStatus('В поиске соперника...');
  const res = await apiFetch('/find', { playerId: String(PLAYER_ID) });
  if (res) {
    if (res.matchId) {
      currentMatchId = res.matchId;
      matchLabel.innerText = currentMatchId;
      modeLabel.innerText = 'railway';
      updateStatus('Найден матч: ' + currentMatchId);
      startPollingMatch();
    } else {
      updateStatus(res.status || 'В очереди на поиск...');
    }
  } else updateStatus('Ошибка поиска');
});

// READY (place ships)
readyBtn.addEventListener('click', async () => {
  if (!allPlaced()) { updateStatus('Сначала размести все корабли'); return; }

  if (modeSelect.value !== 'railway') {
    // mock flow: стартуем матч локально
    updateStatus('Mock: расстановка отправлена — ожидаем старт');
    setTimeout(() => {
      if (!currentMatchId) currentMatchId = 'demo-' + Math.floor(Math.random() * 10000);
      matchLabel.innerText = currentMatchId;
      modeLabel.innerText = 'mock';
      currentTurn = PLAYER_ID;
      turnLabel.innerText = String(currentTurn);
      attackBtn.disabled = false;
      updateStatus('Mock: матч начался — ваш ход');
    }, 600);
    return;
  }

  // railway flow: отправляем расстановку и начинаем опрашивать статус
  updateStatus('Отправка расстановки...');
  const res = await apiFetch('/place-ships', { matchId: currentMatchId, playerId: String(PLAYER_ID), ships: placed });
  if (res && res.ok) {
    updateStatus('Расстановка отправлена — ждём соперника');
    startPollingMatch();
  } else {
    console.error('place-ships failed', res);
    updateStatus('Ошибка отправки: ' + (res && res.error ? res.error : 'no response'));
  }
});

// ATTACK (demo: random)
attackBtn.addEventListener('click', async () => {
  const x = Math.floor(Math.random() * 10), y = Math.floor(Math.random() * 10);
  if (modeSelect.value !== 'railway') {
    updateStatus(`Mock: выстрел в (${x},${y}) — ${Math.random() < 0.3 ? 'hit' : 'miss'}`);
    return;
  }
  if (!currentMatchId) { updateStatus('Нет текущего матча'); return; }
  updateStatus('Отправка выстрела...');
  const res = await apiFetch('/shoot', { matchId: currentMatchId, playerId: String(PLAYER_ID), x, y });
  if (res && res.ok) {
    updateStatus(`Выстрел в (${x},${y}) — ${res.result || 'ok'}`);
    if (res.newTurn) { currentTurn = res.newTurn; turnLabel.innerText = String(currentTurn); }
    if (res.finished) { updateStatus('Матч завершён. Победитель: ' + res.winner); stopPollingMatch(); attackBtn.disabled = true; }
  } else {
    console.error('shoot failed', res);
    updateStatus('Ошибка выстрела: ' + (res && res.error ? res.error : 'no response'));
  }
});

/* ========== Init ========= */
function initUI() {
  buildField();
  renderShipsPanel();
  renderAll();
  modeLabel.innerText = modeSelect.value;
  updateStatus('Готово');
  dbg.style.display = 'none';
}
initUI();
  
</script>
</body>
</html>
